# React 컴포넌트 사용 규칙

React 컴포넌트를 사용할 때 지켜야 할 주요 규칙들은 다음과 같습니다:

1. 컴포넌트 이름은 대문자로 시작

   - 올바른 예: `MyComponent`, `UserProfile`
   - 잘못된 예: `myComponent`, `userProfile`

2. 단일 루트 요소 반환

   - JSX에서 여러 요소를 반환할 때는 하나의 부모 요소로 감싸기
   - React Fragment (`<>...</>`) 사용으로 불필요한 DOM 요소 생성 방지

3. props는 읽기 전용

   - 컴포넌트 내부에서 props 직접 수정 금지
   - props 변경 필요 시 부모 컴포넌트에서 상태 변경

4. state 수정은 setState() 메서드 사용

   - 잘못된 예: `this.state.count = 1`
   - 올바른 예: `this.setState({ count: 1 })`

5. 순수 함수로 컴포넌트 작성

   - 같은 props에 대해 항상 같은 결과 반환
   - 부작용(side effects) 최소화

6. 리스트 아이템에 고유한 key prop 사용

   - 배열 렌더링 시 각 아이템에 고유 key 제공

7. 조건부 렌더링은 삼항 연산자나 && 연산자 사용

   - 예: `{isLoggedIn ? <UserGreeting /> : <GuestGreeting />}`
   - 예: `{showWarning && <WarningBanner />}`

8. 이벤트 핸들러 이름은 'handle'로 시작

   - 예: `handleClick`, `handleSubmit`

9. 단일 책임 원칙 준수

   - 하나의 컴포넌트는 한 가지 일만 담당
   - 필요 시 여러 개의 작은 컴포넌트로 분리

10. 불필요한 렌더링 방지
    - React.memo, useMemo, useCallback 등을 적절히 사용

# 컴포넌트를 사용하는 이유

React에서 컴포넌트를 사용하는 주요 이유는 다음과 같다:

1. 재사용성

   - 동일한 UI 요소를 여러 곳에서 쉽게 재사용할 수 있다.
   - 코드 중복을 줄이고 유지보수를 용이하게 한다.

2. 모듈화

   - 복잡한 UI를 작은 단위로 나누어 관리할 수 있다.
   - 각 컴포넌트는 독립적으로 개발, 테스트, 수정이 가능하다.

3. 가독성 향상

   - 코드를 논리적인 단위로 구분하여 전체 구조를 이해하기 쉽게 만든다.
   - 다른 개발자들과의 협업을 용이하게 한다.

4. 상태 관리 용이성

   - 각 컴포넌트는 자체적인 상태를 가질 수 있어 상태 관리가 용이하다.
   - 부모-자식 컴포넌트 간의 명확한 데이터 흐름을 제공한다.

5. 성능 최적화

   - 필요한 부분만 업데이트하여 전체 애플리케이션의 성능을 향상시킬 수 있다.
   - 가상 DOM을 효율적으로 사용하여 렌더링 성능을 개선한다.

6. 테스트 용이성

   - 각 컴포넌트를 독립적으로 테스트할 수 있어 단위 테스트가 용이하다.
   - 버그 발견과 수정이 더 쉬워진다.

7. 확장성

   - 새로운 기능 추가나 UI 변경 시 기존 코드에 미치는 영향을 최소화할 수 있다.
   - 대규모 애플리케이션 개발에 적합한 구조를 제공한다.

# 컴포넌트를 타 폴더에 분리해서 사용하는 경우

컴포넌트를 다른 폴더로 분리하여 사용할 때 다음과 같은 주의점을 고려해야 한다:

1. 파일 경로 관리

   - 상대 경로를 사용할 때 주의가 필요하다.
   - 프로젝트 구조 변경 시 import 문을 업데이트해야 할 수 있다.

2. 네이밍 규칙

   - 파일명과 컴포넌트명을 일치시켜 혼란을 방지한다.
   - 일관된 네이밍 컨벤션을 유지한다 (예: PascalCase).

3. 순환 참조 방지

   - 컴포넌트 간 순환 참조가 발생하지 않도록 주의한다.
   - 필요한 경우 구조를 재검토하거나 공통 모듈로 분리한다.

4. 불필요한 중첩 방지

   - 폴더 구조가 너무 깊어지지 않도록 주의한다.
   - 관련 컴포넌트들을 적절히 그룹화한다.

5. 재사용성 고려

   - 너무 특정 상황에 종속된 컴포넌트는 재사용이 어려울 수 있다.
   - 범용적으로 사용 가능한 컴포넌트를 설계한다.

6. 문서화

   - 복잡한 컴포넌트의 경우, 사용 방법과 props에 대한 문서를 작성한다.
   - README 파일을 통해 폴더 구조와 컴포넌트 역할을 설명한다.

7. 테스트 파일 위치

   - 테스트 파일을 컴포넌트와 같은 위치에 두거나 별도의 테스트 폴더를 만든다.
   - 일관된 테스트 파일 위치 전략을 유지한다.

8. 빌드 설정

   - 빌드 도구가 분리된 컴포넌트를 올바르게 처리하도록 설정한다.
   - 필요한 경우 별칭(alias)을 사용하여 import 경로를 단순화한다.

9. 상태 관리

   - 컴포넌트 분리 시 상태 관리 전략을 재검토한다.
   - 필요한 경우 상태 관리 라이브러리 사용을 고려한다.

10. 성능 고려
    - 불필요한 컴포넌트 분리로 인한 성능 저하를 주의한다.
    - 대규모 애플리케이션의 경우 코드 분할(Code Splitting)을 고려한다.

# 컴포넌트 css 파일 분리할 때 주의 할 점

    1. 명확한 네이밍 규칙 사용:

      - 컴포넌트 이름을 CSS 클래스 이름에 포함시켜 충돌 방지 (예: Header.css에서 .Header-title).
      - BEM(Block Element Modifier) 같은 명명 규칙 고려.

    2. 스코프 제한:

      - CSS Modules나 Styled Components 같은 기술을 사용하여 스타일 범위를 컴포넌트로 제한.
      - 글로벌 스타일과 충돌하지 않도록 주의.

    3. 선택자 특정성 관리:

      - 너무 구체적인 선택자는 유지보수를 어렵게 만들 수 있으므로 적절한 수준 유지.
      - !important 사용을 최소화하고, 필요한 경우에만 신중히 사용.

    4. 중복 스타일 방지:

      - 공통 스타일은 별도의 파일로 분리하여 재사용.
      - 변수나 믹스인을 활용하여 일관성 유지 (SASS, LESS 등 사용 고려).

    5. 미디어 쿼리 관리:

      - 반응형 디자인을 위한 미디어 쿼리를 효율적으로 관리.
      - 컴포넌트별로 필요한 미디어 쿼리만 포함.

    6. 파일 크기 관리:

      - 불필요하게 큰 CSS 파일은 성능에 영향을 줄 수 있으므로 적절히 분할.
      - 사용하지 않는 스타일은 제거.

    7. CSS-in-JS 고려:

      - 동적 스타일링이 많이 필요한 경우 CSS-in-JS 라이브러리 사용 검토.

    8. 일관성 유지:

      - 프로젝트 전체에서 일관된 스타일링 방식 사용.
      - 스타일 가이드 또는 디자인 시스템 활용.

    9. 브라우저 호환성:

      - 벤더 프리픽스 사용 시 주의 (자동화 도구 사용 고려).
      - 크로스 브라우저 테스트 수행.

    10. 성능 최적화:
      - CSS 파일 압축 및 최적화.
      - Critical CSS 기법 고려하여 초기 로딩 성능 개선.

    11. CSS 파일은 컴포넌트화 되지 않는다:

        - CSS 파일 자체는 React 컴포넌트처럼 동작하지 않음.
        - 스타일은 전역적으로 적용되며, 컴포넌트의 캡슐화와는 다르게 작동.
        - 이로 인해 클래스 이름 충돌이나 의도치 않은 스타일 상속 등의 문제가 발생할 수 있음.
        - CSS Modules나 Styled Components 같은 기술을 사용하면 이러한 문제를 해결하고 CSS를 컴포넌트와 더 밀접하게 연결할 수 있음.
        - 그러나 이러한 기술을 사용하더라도, CSS 파일 자체가 React 컴포넌트가 되는 것은 아니며, 여전히 별도의 스타일 관리가 필요함.
